/*
Oura API Documentation

# Overview   The Oura API allows Oura users and partner applications to improve their user experience with Oura data.  This document describes the Oura API Version 2 (V2), which supports access to the latest Oura Ring data types.  For access to other data types—which have not yet migrated to V2—refer to the [Oura API Version 1 (V1)](https://cloud.ouraring.com/docs/) documentation.  # Data Access  Individual Oura users can access their own data through the API by using a [Personal Access Token](https://cloud.ouraring.com/personal-access-tokens).  If you want to retrieve data for multiple users, a registered [API Application](https://cloud.ouraring.com/oauth/applications) is required.  API Applications are limited to **10** users before requiring approval from Oura. There is no limit once an application is approved.  Additionally, Oura users **must provide consent** to share each data type an API Application has access to.  All data access requests through the Oura API require [Authentication](https://cloud.ouraring.com/docs/authentication).  Additionally, we recommend that Oura users keep their mobile app updated to support API access for the latest data types.  # Authentication  The Oura API provides two methods for Authentication: (1) the OAuth2 protocol and (2) Personal Access Tokens. For more information on the OAuth2 flow, see our [Authentication instructions](https://cloud.ouraring.com/docs/authentication).  Access tokens must be included in the request header as follows: ```http GET /v2/usercollection/personal_info HTTP/1.1 Host: api.ouraring.com Authorization: Bearer <token> ```  # Oura HTTP Response Codes  | Response Code                        | Description | | ------------------------------------ | - | | 200 OK                               | Successful Response         | | 400 Query Parameter Validation Error | The request contains query parameters that are invalid or incorrectly formatted. | | 429 Request Rate Limit Exceeded        | The API is rate limited to 5000 requests in a 5 minute period. You will receive a 429 error code if you exceed this limit. [Contact us](mailto:api-support@ouraring.com) if you expect your usage to exceed this limit.| 

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package oura

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
)


// SandboxRoutesAPIService SandboxRoutesAPI service
type SandboxRoutesAPIService service

type ApiSandboxMultipleDailyActivityDocumentsV2SandboxUsercollectionDailyActivityGetRequest struct {
	ctx context.Context
	ApiService *SandboxRoutesAPIService
	startDate *StartDate
	endDate *EndDate1
	nextToken *string
}

func (r ApiSandboxMultipleDailyActivityDocumentsV2SandboxUsercollectionDailyActivityGetRequest) StartDate(startDate StartDate) ApiSandboxMultipleDailyActivityDocumentsV2SandboxUsercollectionDailyActivityGetRequest {
	r.startDate = &startDate
	return r
}

func (r ApiSandboxMultipleDailyActivityDocumentsV2SandboxUsercollectionDailyActivityGetRequest) EndDate(endDate EndDate1) ApiSandboxMultipleDailyActivityDocumentsV2SandboxUsercollectionDailyActivityGetRequest {
	r.endDate = &endDate
	return r
}

func (r ApiSandboxMultipleDailyActivityDocumentsV2SandboxUsercollectionDailyActivityGetRequest) NextToken(nextToken string) ApiSandboxMultipleDailyActivityDocumentsV2SandboxUsercollectionDailyActivityGetRequest {
	r.nextToken = &nextToken
	return r
}

func (r ApiSandboxMultipleDailyActivityDocumentsV2SandboxUsercollectionDailyActivityGetRequest) Execute() (*MultiDocumentResponseDailyActivityModel, *http.Response, error) {
	return r.ApiService.SandboxMultipleDailyActivityDocumentsV2SandboxUsercollectionDailyActivityGetExecute(r)
}

/*
SandboxMultipleDailyActivityDocumentsV2SandboxUsercollectionDailyActivityGet Sandbox - Multiple Daily Activity Documents

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSandboxMultipleDailyActivityDocumentsV2SandboxUsercollectionDailyActivityGetRequest
*/
func (a *SandboxRoutesAPIService) SandboxMultipleDailyActivityDocumentsV2SandboxUsercollectionDailyActivityGet(ctx context.Context) ApiSandboxMultipleDailyActivityDocumentsV2SandboxUsercollectionDailyActivityGetRequest {
	return ApiSandboxMultipleDailyActivityDocumentsV2SandboxUsercollectionDailyActivityGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MultiDocumentResponseDailyActivityModel
func (a *SandboxRoutesAPIService) SandboxMultipleDailyActivityDocumentsV2SandboxUsercollectionDailyActivityGetExecute(r ApiSandboxMultipleDailyActivityDocumentsV2SandboxUsercollectionDailyActivityGetRequest) (*MultiDocumentResponseDailyActivityModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiDocumentResponseDailyActivityModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxRoutesAPIService.SandboxMultipleDailyActivityDocumentsV2SandboxUsercollectionDailyActivityGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/sandbox/usercollection/daily_activity"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.nextToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "next_token", r.nextToken, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSandboxMultipleDailyCardiovascularAgeDocumentsV2SandboxUsercollectionDailyCardiovascularAgeGetRequest struct {
	ctx context.Context
	ApiService *SandboxRoutesAPIService
	startDate *StartDate
	endDate *EndDate1
	nextToken *string
}

func (r ApiSandboxMultipleDailyCardiovascularAgeDocumentsV2SandboxUsercollectionDailyCardiovascularAgeGetRequest) StartDate(startDate StartDate) ApiSandboxMultipleDailyCardiovascularAgeDocumentsV2SandboxUsercollectionDailyCardiovascularAgeGetRequest {
	r.startDate = &startDate
	return r
}

func (r ApiSandboxMultipleDailyCardiovascularAgeDocumentsV2SandboxUsercollectionDailyCardiovascularAgeGetRequest) EndDate(endDate EndDate1) ApiSandboxMultipleDailyCardiovascularAgeDocumentsV2SandboxUsercollectionDailyCardiovascularAgeGetRequest {
	r.endDate = &endDate
	return r
}

func (r ApiSandboxMultipleDailyCardiovascularAgeDocumentsV2SandboxUsercollectionDailyCardiovascularAgeGetRequest) NextToken(nextToken string) ApiSandboxMultipleDailyCardiovascularAgeDocumentsV2SandboxUsercollectionDailyCardiovascularAgeGetRequest {
	r.nextToken = &nextToken
	return r
}

func (r ApiSandboxMultipleDailyCardiovascularAgeDocumentsV2SandboxUsercollectionDailyCardiovascularAgeGetRequest) Execute() (*MultiDocumentResponseDailyCardiovascularAgeModel, *http.Response, error) {
	return r.ApiService.SandboxMultipleDailyCardiovascularAgeDocumentsV2SandboxUsercollectionDailyCardiovascularAgeGetExecute(r)
}

/*
SandboxMultipleDailyCardiovascularAgeDocumentsV2SandboxUsercollectionDailyCardiovascularAgeGet Sandbox - Multiple Daily Cardiovascular Age Documents

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSandboxMultipleDailyCardiovascularAgeDocumentsV2SandboxUsercollectionDailyCardiovascularAgeGetRequest
*/
func (a *SandboxRoutesAPIService) SandboxMultipleDailyCardiovascularAgeDocumentsV2SandboxUsercollectionDailyCardiovascularAgeGet(ctx context.Context) ApiSandboxMultipleDailyCardiovascularAgeDocumentsV2SandboxUsercollectionDailyCardiovascularAgeGetRequest {
	return ApiSandboxMultipleDailyCardiovascularAgeDocumentsV2SandboxUsercollectionDailyCardiovascularAgeGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MultiDocumentResponseDailyCardiovascularAgeModel
func (a *SandboxRoutesAPIService) SandboxMultipleDailyCardiovascularAgeDocumentsV2SandboxUsercollectionDailyCardiovascularAgeGetExecute(r ApiSandboxMultipleDailyCardiovascularAgeDocumentsV2SandboxUsercollectionDailyCardiovascularAgeGetRequest) (*MultiDocumentResponseDailyCardiovascularAgeModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiDocumentResponseDailyCardiovascularAgeModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxRoutesAPIService.SandboxMultipleDailyCardiovascularAgeDocumentsV2SandboxUsercollectionDailyCardiovascularAgeGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/sandbox/usercollection/daily_cardiovascular_age"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.nextToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "next_token", r.nextToken, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSandboxMultipleDailyReadinessDocumentsV2SandboxUsercollectionDailyReadinessGetRequest struct {
	ctx context.Context
	ApiService *SandboxRoutesAPIService
	startDate *StartDate
	endDate *EndDate1
	nextToken *string
}

func (r ApiSandboxMultipleDailyReadinessDocumentsV2SandboxUsercollectionDailyReadinessGetRequest) StartDate(startDate StartDate) ApiSandboxMultipleDailyReadinessDocumentsV2SandboxUsercollectionDailyReadinessGetRequest {
	r.startDate = &startDate
	return r
}

func (r ApiSandboxMultipleDailyReadinessDocumentsV2SandboxUsercollectionDailyReadinessGetRequest) EndDate(endDate EndDate1) ApiSandboxMultipleDailyReadinessDocumentsV2SandboxUsercollectionDailyReadinessGetRequest {
	r.endDate = &endDate
	return r
}

func (r ApiSandboxMultipleDailyReadinessDocumentsV2SandboxUsercollectionDailyReadinessGetRequest) NextToken(nextToken string) ApiSandboxMultipleDailyReadinessDocumentsV2SandboxUsercollectionDailyReadinessGetRequest {
	r.nextToken = &nextToken
	return r
}

func (r ApiSandboxMultipleDailyReadinessDocumentsV2SandboxUsercollectionDailyReadinessGetRequest) Execute() (*MultiDocumentResponseDailyReadinessModel, *http.Response, error) {
	return r.ApiService.SandboxMultipleDailyReadinessDocumentsV2SandboxUsercollectionDailyReadinessGetExecute(r)
}

/*
SandboxMultipleDailyReadinessDocumentsV2SandboxUsercollectionDailyReadinessGet Sandbox - Multiple Daily Readiness Documents

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSandboxMultipleDailyReadinessDocumentsV2SandboxUsercollectionDailyReadinessGetRequest
*/
func (a *SandboxRoutesAPIService) SandboxMultipleDailyReadinessDocumentsV2SandboxUsercollectionDailyReadinessGet(ctx context.Context) ApiSandboxMultipleDailyReadinessDocumentsV2SandboxUsercollectionDailyReadinessGetRequest {
	return ApiSandboxMultipleDailyReadinessDocumentsV2SandboxUsercollectionDailyReadinessGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MultiDocumentResponseDailyReadinessModel
func (a *SandboxRoutesAPIService) SandboxMultipleDailyReadinessDocumentsV2SandboxUsercollectionDailyReadinessGetExecute(r ApiSandboxMultipleDailyReadinessDocumentsV2SandboxUsercollectionDailyReadinessGetRequest) (*MultiDocumentResponseDailyReadinessModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiDocumentResponseDailyReadinessModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxRoutesAPIService.SandboxMultipleDailyReadinessDocumentsV2SandboxUsercollectionDailyReadinessGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/sandbox/usercollection/daily_readiness"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.nextToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "next_token", r.nextToken, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSandboxMultipleDailyResilienceDocumentsV2SandboxUsercollectionDailyResilienceGetRequest struct {
	ctx context.Context
	ApiService *SandboxRoutesAPIService
	startDate *StartDate
	endDate *EndDate1
	nextToken *string
}

func (r ApiSandboxMultipleDailyResilienceDocumentsV2SandboxUsercollectionDailyResilienceGetRequest) StartDate(startDate StartDate) ApiSandboxMultipleDailyResilienceDocumentsV2SandboxUsercollectionDailyResilienceGetRequest {
	r.startDate = &startDate
	return r
}

func (r ApiSandboxMultipleDailyResilienceDocumentsV2SandboxUsercollectionDailyResilienceGetRequest) EndDate(endDate EndDate1) ApiSandboxMultipleDailyResilienceDocumentsV2SandboxUsercollectionDailyResilienceGetRequest {
	r.endDate = &endDate
	return r
}

func (r ApiSandboxMultipleDailyResilienceDocumentsV2SandboxUsercollectionDailyResilienceGetRequest) NextToken(nextToken string) ApiSandboxMultipleDailyResilienceDocumentsV2SandboxUsercollectionDailyResilienceGetRequest {
	r.nextToken = &nextToken
	return r
}

func (r ApiSandboxMultipleDailyResilienceDocumentsV2SandboxUsercollectionDailyResilienceGetRequest) Execute() (*MultiDocumentResponseDailyResilienceModel, *http.Response, error) {
	return r.ApiService.SandboxMultipleDailyResilienceDocumentsV2SandboxUsercollectionDailyResilienceGetExecute(r)
}

/*
SandboxMultipleDailyResilienceDocumentsV2SandboxUsercollectionDailyResilienceGet Sandbox - Multiple Daily Resilience Documents

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSandboxMultipleDailyResilienceDocumentsV2SandboxUsercollectionDailyResilienceGetRequest
*/
func (a *SandboxRoutesAPIService) SandboxMultipleDailyResilienceDocumentsV2SandboxUsercollectionDailyResilienceGet(ctx context.Context) ApiSandboxMultipleDailyResilienceDocumentsV2SandboxUsercollectionDailyResilienceGetRequest {
	return ApiSandboxMultipleDailyResilienceDocumentsV2SandboxUsercollectionDailyResilienceGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MultiDocumentResponseDailyResilienceModel
func (a *SandboxRoutesAPIService) SandboxMultipleDailyResilienceDocumentsV2SandboxUsercollectionDailyResilienceGetExecute(r ApiSandboxMultipleDailyResilienceDocumentsV2SandboxUsercollectionDailyResilienceGetRequest) (*MultiDocumentResponseDailyResilienceModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiDocumentResponseDailyResilienceModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxRoutesAPIService.SandboxMultipleDailyResilienceDocumentsV2SandboxUsercollectionDailyResilienceGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/sandbox/usercollection/daily_resilience"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.nextToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "next_token", r.nextToken, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSandboxMultipleDailySleepDocumentsV2SandboxUsercollectionDailySleepGetRequest struct {
	ctx context.Context
	ApiService *SandboxRoutesAPIService
	startDate *StartDate
	endDate *EndDate1
	nextToken *string
}

func (r ApiSandboxMultipleDailySleepDocumentsV2SandboxUsercollectionDailySleepGetRequest) StartDate(startDate StartDate) ApiSandboxMultipleDailySleepDocumentsV2SandboxUsercollectionDailySleepGetRequest {
	r.startDate = &startDate
	return r
}

func (r ApiSandboxMultipleDailySleepDocumentsV2SandboxUsercollectionDailySleepGetRequest) EndDate(endDate EndDate1) ApiSandboxMultipleDailySleepDocumentsV2SandboxUsercollectionDailySleepGetRequest {
	r.endDate = &endDate
	return r
}

func (r ApiSandboxMultipleDailySleepDocumentsV2SandboxUsercollectionDailySleepGetRequest) NextToken(nextToken string) ApiSandboxMultipleDailySleepDocumentsV2SandboxUsercollectionDailySleepGetRequest {
	r.nextToken = &nextToken
	return r
}

func (r ApiSandboxMultipleDailySleepDocumentsV2SandboxUsercollectionDailySleepGetRequest) Execute() (*MultiDocumentResponseDailySleepModel, *http.Response, error) {
	return r.ApiService.SandboxMultipleDailySleepDocumentsV2SandboxUsercollectionDailySleepGetExecute(r)
}

/*
SandboxMultipleDailySleepDocumentsV2SandboxUsercollectionDailySleepGet Sandbox - Multiple Daily Sleep Documents

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSandboxMultipleDailySleepDocumentsV2SandboxUsercollectionDailySleepGetRequest
*/
func (a *SandboxRoutesAPIService) SandboxMultipleDailySleepDocumentsV2SandboxUsercollectionDailySleepGet(ctx context.Context) ApiSandboxMultipleDailySleepDocumentsV2SandboxUsercollectionDailySleepGetRequest {
	return ApiSandboxMultipleDailySleepDocumentsV2SandboxUsercollectionDailySleepGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MultiDocumentResponseDailySleepModel
func (a *SandboxRoutesAPIService) SandboxMultipleDailySleepDocumentsV2SandboxUsercollectionDailySleepGetExecute(r ApiSandboxMultipleDailySleepDocumentsV2SandboxUsercollectionDailySleepGetRequest) (*MultiDocumentResponseDailySleepModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiDocumentResponseDailySleepModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxRoutesAPIService.SandboxMultipleDailySleepDocumentsV2SandboxUsercollectionDailySleepGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/sandbox/usercollection/daily_sleep"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.nextToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "next_token", r.nextToken, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSandboxMultipleDailySpo2DocumentsV2SandboxUsercollectionDailySpo2GetRequest struct {
	ctx context.Context
	ApiService *SandboxRoutesAPIService
	startDate *StartDate
	endDate *EndDate1
	nextToken *string
}

func (r ApiSandboxMultipleDailySpo2DocumentsV2SandboxUsercollectionDailySpo2GetRequest) StartDate(startDate StartDate) ApiSandboxMultipleDailySpo2DocumentsV2SandboxUsercollectionDailySpo2GetRequest {
	r.startDate = &startDate
	return r
}

func (r ApiSandboxMultipleDailySpo2DocumentsV2SandboxUsercollectionDailySpo2GetRequest) EndDate(endDate EndDate1) ApiSandboxMultipleDailySpo2DocumentsV2SandboxUsercollectionDailySpo2GetRequest {
	r.endDate = &endDate
	return r
}

func (r ApiSandboxMultipleDailySpo2DocumentsV2SandboxUsercollectionDailySpo2GetRequest) NextToken(nextToken string) ApiSandboxMultipleDailySpo2DocumentsV2SandboxUsercollectionDailySpo2GetRequest {
	r.nextToken = &nextToken
	return r
}

func (r ApiSandboxMultipleDailySpo2DocumentsV2SandboxUsercollectionDailySpo2GetRequest) Execute() (*MultiDocumentResponseDailySpO2Model, *http.Response, error) {
	return r.ApiService.SandboxMultipleDailySpo2DocumentsV2SandboxUsercollectionDailySpo2GetExecute(r)
}

/*
SandboxMultipleDailySpo2DocumentsV2SandboxUsercollectionDailySpo2Get Sandbox - Multiple Daily Spo2 Documents

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSandboxMultipleDailySpo2DocumentsV2SandboxUsercollectionDailySpo2GetRequest
*/
func (a *SandboxRoutesAPIService) SandboxMultipleDailySpo2DocumentsV2SandboxUsercollectionDailySpo2Get(ctx context.Context) ApiSandboxMultipleDailySpo2DocumentsV2SandboxUsercollectionDailySpo2GetRequest {
	return ApiSandboxMultipleDailySpo2DocumentsV2SandboxUsercollectionDailySpo2GetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MultiDocumentResponseDailySpO2Model
func (a *SandboxRoutesAPIService) SandboxMultipleDailySpo2DocumentsV2SandboxUsercollectionDailySpo2GetExecute(r ApiSandboxMultipleDailySpo2DocumentsV2SandboxUsercollectionDailySpo2GetRequest) (*MultiDocumentResponseDailySpO2Model, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiDocumentResponseDailySpO2Model
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxRoutesAPIService.SandboxMultipleDailySpo2DocumentsV2SandboxUsercollectionDailySpo2Get")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/sandbox/usercollection/daily_spo2"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.nextToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "next_token", r.nextToken, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSandboxMultipleDailyStressDocumentsV2SandboxUsercollectionDailyStressGetRequest struct {
	ctx context.Context
	ApiService *SandboxRoutesAPIService
	startDate *StartDate
	endDate *EndDate1
	nextToken *string
}

func (r ApiSandboxMultipleDailyStressDocumentsV2SandboxUsercollectionDailyStressGetRequest) StartDate(startDate StartDate) ApiSandboxMultipleDailyStressDocumentsV2SandboxUsercollectionDailyStressGetRequest {
	r.startDate = &startDate
	return r
}

func (r ApiSandboxMultipleDailyStressDocumentsV2SandboxUsercollectionDailyStressGetRequest) EndDate(endDate EndDate1) ApiSandboxMultipleDailyStressDocumentsV2SandboxUsercollectionDailyStressGetRequest {
	r.endDate = &endDate
	return r
}

func (r ApiSandboxMultipleDailyStressDocumentsV2SandboxUsercollectionDailyStressGetRequest) NextToken(nextToken string) ApiSandboxMultipleDailyStressDocumentsV2SandboxUsercollectionDailyStressGetRequest {
	r.nextToken = &nextToken
	return r
}

func (r ApiSandboxMultipleDailyStressDocumentsV2SandboxUsercollectionDailyStressGetRequest) Execute() (*MultiDocumentResponseDailyStressModel, *http.Response, error) {
	return r.ApiService.SandboxMultipleDailyStressDocumentsV2SandboxUsercollectionDailyStressGetExecute(r)
}

/*
SandboxMultipleDailyStressDocumentsV2SandboxUsercollectionDailyStressGet Sandbox - Multiple Daily Stress Documents

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSandboxMultipleDailyStressDocumentsV2SandboxUsercollectionDailyStressGetRequest
*/
func (a *SandboxRoutesAPIService) SandboxMultipleDailyStressDocumentsV2SandboxUsercollectionDailyStressGet(ctx context.Context) ApiSandboxMultipleDailyStressDocumentsV2SandboxUsercollectionDailyStressGetRequest {
	return ApiSandboxMultipleDailyStressDocumentsV2SandboxUsercollectionDailyStressGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MultiDocumentResponseDailyStressModel
func (a *SandboxRoutesAPIService) SandboxMultipleDailyStressDocumentsV2SandboxUsercollectionDailyStressGetExecute(r ApiSandboxMultipleDailyStressDocumentsV2SandboxUsercollectionDailyStressGetRequest) (*MultiDocumentResponseDailyStressModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiDocumentResponseDailyStressModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxRoutesAPIService.SandboxMultipleDailyStressDocumentsV2SandboxUsercollectionDailyStressGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/sandbox/usercollection/daily_stress"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.nextToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "next_token", r.nextToken, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSandboxMultipleEnhancedTagDocumentsV2SandboxUsercollectionEnhancedTagGetRequest struct {
	ctx context.Context
	ApiService *SandboxRoutesAPIService
	startDate *StartDate
	endDate *EndDate1
	nextToken *string
}

func (r ApiSandboxMultipleEnhancedTagDocumentsV2SandboxUsercollectionEnhancedTagGetRequest) StartDate(startDate StartDate) ApiSandboxMultipleEnhancedTagDocumentsV2SandboxUsercollectionEnhancedTagGetRequest {
	r.startDate = &startDate
	return r
}

func (r ApiSandboxMultipleEnhancedTagDocumentsV2SandboxUsercollectionEnhancedTagGetRequest) EndDate(endDate EndDate1) ApiSandboxMultipleEnhancedTagDocumentsV2SandboxUsercollectionEnhancedTagGetRequest {
	r.endDate = &endDate
	return r
}

func (r ApiSandboxMultipleEnhancedTagDocumentsV2SandboxUsercollectionEnhancedTagGetRequest) NextToken(nextToken string) ApiSandboxMultipleEnhancedTagDocumentsV2SandboxUsercollectionEnhancedTagGetRequest {
	r.nextToken = &nextToken
	return r
}

func (r ApiSandboxMultipleEnhancedTagDocumentsV2SandboxUsercollectionEnhancedTagGetRequest) Execute() (*MultiDocumentResponseEnhancedTagModel, *http.Response, error) {
	return r.ApiService.SandboxMultipleEnhancedTagDocumentsV2SandboxUsercollectionEnhancedTagGetExecute(r)
}

/*
SandboxMultipleEnhancedTagDocumentsV2SandboxUsercollectionEnhancedTagGet Sandbox - Multiple Enhanced Tag Documents

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSandboxMultipleEnhancedTagDocumentsV2SandboxUsercollectionEnhancedTagGetRequest
*/
func (a *SandboxRoutesAPIService) SandboxMultipleEnhancedTagDocumentsV2SandboxUsercollectionEnhancedTagGet(ctx context.Context) ApiSandboxMultipleEnhancedTagDocumentsV2SandboxUsercollectionEnhancedTagGetRequest {
	return ApiSandboxMultipleEnhancedTagDocumentsV2SandboxUsercollectionEnhancedTagGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MultiDocumentResponseEnhancedTagModel
func (a *SandboxRoutesAPIService) SandboxMultipleEnhancedTagDocumentsV2SandboxUsercollectionEnhancedTagGetExecute(r ApiSandboxMultipleEnhancedTagDocumentsV2SandboxUsercollectionEnhancedTagGetRequest) (*MultiDocumentResponseEnhancedTagModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiDocumentResponseEnhancedTagModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxRoutesAPIService.SandboxMultipleEnhancedTagDocumentsV2SandboxUsercollectionEnhancedTagGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/sandbox/usercollection/enhanced_tag"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.nextToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "next_token", r.nextToken, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSandboxMultipleHeartrateDocumentsV2SandboxUsercollectionHeartrateGetRequest struct {
	ctx context.Context
	ApiService *SandboxRoutesAPIService
	startDatetime *time.Time
	endDatetime *time.Time
	nextToken *string
}

func (r ApiSandboxMultipleHeartrateDocumentsV2SandboxUsercollectionHeartrateGetRequest) StartDatetime(startDatetime time.Time) ApiSandboxMultipleHeartrateDocumentsV2SandboxUsercollectionHeartrateGetRequest {
	r.startDatetime = &startDatetime
	return r
}

func (r ApiSandboxMultipleHeartrateDocumentsV2SandboxUsercollectionHeartrateGetRequest) EndDatetime(endDatetime time.Time) ApiSandboxMultipleHeartrateDocumentsV2SandboxUsercollectionHeartrateGetRequest {
	r.endDatetime = &endDatetime
	return r
}

func (r ApiSandboxMultipleHeartrateDocumentsV2SandboxUsercollectionHeartrateGetRequest) NextToken(nextToken string) ApiSandboxMultipleHeartrateDocumentsV2SandboxUsercollectionHeartrateGetRequest {
	r.nextToken = &nextToken
	return r
}

func (r ApiSandboxMultipleHeartrateDocumentsV2SandboxUsercollectionHeartrateGetRequest) Execute() (*TimeSeriesResponseHeartRateModel, *http.Response, error) {
	return r.ApiService.SandboxMultipleHeartrateDocumentsV2SandboxUsercollectionHeartrateGetExecute(r)
}

/*
SandboxMultipleHeartrateDocumentsV2SandboxUsercollectionHeartrateGet Sandbox - Multiple Heartrate Documents

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSandboxMultipleHeartrateDocumentsV2SandboxUsercollectionHeartrateGetRequest
*/
func (a *SandboxRoutesAPIService) SandboxMultipleHeartrateDocumentsV2SandboxUsercollectionHeartrateGet(ctx context.Context) ApiSandboxMultipleHeartrateDocumentsV2SandboxUsercollectionHeartrateGetRequest {
	return ApiSandboxMultipleHeartrateDocumentsV2SandboxUsercollectionHeartrateGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TimeSeriesResponseHeartRateModel
func (a *SandboxRoutesAPIService) SandboxMultipleHeartrateDocumentsV2SandboxUsercollectionHeartrateGetExecute(r ApiSandboxMultipleHeartrateDocumentsV2SandboxUsercollectionHeartrateGetRequest) (*TimeSeriesResponseHeartRateModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TimeSeriesResponseHeartRateModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxRoutesAPIService.SandboxMultipleHeartrateDocumentsV2SandboxUsercollectionHeartrateGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/sandbox/usercollection/heartrate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startDatetime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_datetime", r.startDatetime, "form", "")
	}
	if r.endDatetime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_datetime", r.endDatetime, "form", "")
	}
	if r.nextToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "next_token", r.nextToken, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSandboxMultipleRestModePeriodDocumentsV2SandboxUsercollectionRestModePeriodGetRequest struct {
	ctx context.Context
	ApiService *SandboxRoutesAPIService
	startDate *StartDate
	endDate *EndDate1
	nextToken *string
}

func (r ApiSandboxMultipleRestModePeriodDocumentsV2SandboxUsercollectionRestModePeriodGetRequest) StartDate(startDate StartDate) ApiSandboxMultipleRestModePeriodDocumentsV2SandboxUsercollectionRestModePeriodGetRequest {
	r.startDate = &startDate
	return r
}

func (r ApiSandboxMultipleRestModePeriodDocumentsV2SandboxUsercollectionRestModePeriodGetRequest) EndDate(endDate EndDate1) ApiSandboxMultipleRestModePeriodDocumentsV2SandboxUsercollectionRestModePeriodGetRequest {
	r.endDate = &endDate
	return r
}

func (r ApiSandboxMultipleRestModePeriodDocumentsV2SandboxUsercollectionRestModePeriodGetRequest) NextToken(nextToken string) ApiSandboxMultipleRestModePeriodDocumentsV2SandboxUsercollectionRestModePeriodGetRequest {
	r.nextToken = &nextToken
	return r
}

func (r ApiSandboxMultipleRestModePeriodDocumentsV2SandboxUsercollectionRestModePeriodGetRequest) Execute() (*MultiDocumentResponseRestModePeriodModel, *http.Response, error) {
	return r.ApiService.SandboxMultipleRestModePeriodDocumentsV2SandboxUsercollectionRestModePeriodGetExecute(r)
}

/*
SandboxMultipleRestModePeriodDocumentsV2SandboxUsercollectionRestModePeriodGet Sandbox - Multiple Rest Mode Period Documents

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSandboxMultipleRestModePeriodDocumentsV2SandboxUsercollectionRestModePeriodGetRequest
*/
func (a *SandboxRoutesAPIService) SandboxMultipleRestModePeriodDocumentsV2SandboxUsercollectionRestModePeriodGet(ctx context.Context) ApiSandboxMultipleRestModePeriodDocumentsV2SandboxUsercollectionRestModePeriodGetRequest {
	return ApiSandboxMultipleRestModePeriodDocumentsV2SandboxUsercollectionRestModePeriodGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MultiDocumentResponseRestModePeriodModel
func (a *SandboxRoutesAPIService) SandboxMultipleRestModePeriodDocumentsV2SandboxUsercollectionRestModePeriodGetExecute(r ApiSandboxMultipleRestModePeriodDocumentsV2SandboxUsercollectionRestModePeriodGetRequest) (*MultiDocumentResponseRestModePeriodModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiDocumentResponseRestModePeriodModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxRoutesAPIService.SandboxMultipleRestModePeriodDocumentsV2SandboxUsercollectionRestModePeriodGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/sandbox/usercollection/rest_mode_period"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.nextToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "next_token", r.nextToken, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSandboxMultipleRingConfigurationDocumentsV2SandboxUsercollectionRingConfigurationGetRequest struct {
	ctx context.Context
	ApiService *SandboxRoutesAPIService
	nextToken *string
}

func (r ApiSandboxMultipleRingConfigurationDocumentsV2SandboxUsercollectionRingConfigurationGetRequest) NextToken(nextToken string) ApiSandboxMultipleRingConfigurationDocumentsV2SandboxUsercollectionRingConfigurationGetRequest {
	r.nextToken = &nextToken
	return r
}

func (r ApiSandboxMultipleRingConfigurationDocumentsV2SandboxUsercollectionRingConfigurationGetRequest) Execute() (*MultiDocumentResponseRingConfigurationModel, *http.Response, error) {
	return r.ApiService.SandboxMultipleRingConfigurationDocumentsV2SandboxUsercollectionRingConfigurationGetExecute(r)
}

/*
SandboxMultipleRingConfigurationDocumentsV2SandboxUsercollectionRingConfigurationGet Sandbox - Multiple Ring Configuration Documents

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSandboxMultipleRingConfigurationDocumentsV2SandboxUsercollectionRingConfigurationGetRequest
*/
func (a *SandboxRoutesAPIService) SandboxMultipleRingConfigurationDocumentsV2SandboxUsercollectionRingConfigurationGet(ctx context.Context) ApiSandboxMultipleRingConfigurationDocumentsV2SandboxUsercollectionRingConfigurationGetRequest {
	return ApiSandboxMultipleRingConfigurationDocumentsV2SandboxUsercollectionRingConfigurationGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MultiDocumentResponseRingConfigurationModel
func (a *SandboxRoutesAPIService) SandboxMultipleRingConfigurationDocumentsV2SandboxUsercollectionRingConfigurationGetExecute(r ApiSandboxMultipleRingConfigurationDocumentsV2SandboxUsercollectionRingConfigurationGetRequest) (*MultiDocumentResponseRingConfigurationModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiDocumentResponseRingConfigurationModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxRoutesAPIService.SandboxMultipleRingConfigurationDocumentsV2SandboxUsercollectionRingConfigurationGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/sandbox/usercollection/ring_configuration"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.nextToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "next_token", r.nextToken, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSandboxMultipleSessionDocumentsV2SandboxUsercollectionSessionGetRequest struct {
	ctx context.Context
	ApiService *SandboxRoutesAPIService
	startDate *StartDate
	endDate *EndDate1
	nextToken *string
}

func (r ApiSandboxMultipleSessionDocumentsV2SandboxUsercollectionSessionGetRequest) StartDate(startDate StartDate) ApiSandboxMultipleSessionDocumentsV2SandboxUsercollectionSessionGetRequest {
	r.startDate = &startDate
	return r
}

func (r ApiSandboxMultipleSessionDocumentsV2SandboxUsercollectionSessionGetRequest) EndDate(endDate EndDate1) ApiSandboxMultipleSessionDocumentsV2SandboxUsercollectionSessionGetRequest {
	r.endDate = &endDate
	return r
}

func (r ApiSandboxMultipleSessionDocumentsV2SandboxUsercollectionSessionGetRequest) NextToken(nextToken string) ApiSandboxMultipleSessionDocumentsV2SandboxUsercollectionSessionGetRequest {
	r.nextToken = &nextToken
	return r
}

func (r ApiSandboxMultipleSessionDocumentsV2SandboxUsercollectionSessionGetRequest) Execute() (*MultiDocumentResponseSessionModel, *http.Response, error) {
	return r.ApiService.SandboxMultipleSessionDocumentsV2SandboxUsercollectionSessionGetExecute(r)
}

/*
SandboxMultipleSessionDocumentsV2SandboxUsercollectionSessionGet Sandbox - Multiple Session Documents

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSandboxMultipleSessionDocumentsV2SandboxUsercollectionSessionGetRequest
*/
func (a *SandboxRoutesAPIService) SandboxMultipleSessionDocumentsV2SandboxUsercollectionSessionGet(ctx context.Context) ApiSandboxMultipleSessionDocumentsV2SandboxUsercollectionSessionGetRequest {
	return ApiSandboxMultipleSessionDocumentsV2SandboxUsercollectionSessionGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MultiDocumentResponseSessionModel
func (a *SandboxRoutesAPIService) SandboxMultipleSessionDocumentsV2SandboxUsercollectionSessionGetExecute(r ApiSandboxMultipleSessionDocumentsV2SandboxUsercollectionSessionGetRequest) (*MultiDocumentResponseSessionModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiDocumentResponseSessionModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxRoutesAPIService.SandboxMultipleSessionDocumentsV2SandboxUsercollectionSessionGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/sandbox/usercollection/session"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.nextToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "next_token", r.nextToken, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSandboxMultipleSleepDocumentsV2SandboxUsercollectionSleepGetRequest struct {
	ctx context.Context
	ApiService *SandboxRoutesAPIService
	startDate *StartDate
	endDate *EndDate1
	nextToken *string
}

func (r ApiSandboxMultipleSleepDocumentsV2SandboxUsercollectionSleepGetRequest) StartDate(startDate StartDate) ApiSandboxMultipleSleepDocumentsV2SandboxUsercollectionSleepGetRequest {
	r.startDate = &startDate
	return r
}

func (r ApiSandboxMultipleSleepDocumentsV2SandboxUsercollectionSleepGetRequest) EndDate(endDate EndDate1) ApiSandboxMultipleSleepDocumentsV2SandboxUsercollectionSleepGetRequest {
	r.endDate = &endDate
	return r
}

func (r ApiSandboxMultipleSleepDocumentsV2SandboxUsercollectionSleepGetRequest) NextToken(nextToken string) ApiSandboxMultipleSleepDocumentsV2SandboxUsercollectionSleepGetRequest {
	r.nextToken = &nextToken
	return r
}

func (r ApiSandboxMultipleSleepDocumentsV2SandboxUsercollectionSleepGetRequest) Execute() (*MultiDocumentResponseSleepModel, *http.Response, error) {
	return r.ApiService.SandboxMultipleSleepDocumentsV2SandboxUsercollectionSleepGetExecute(r)
}

/*
SandboxMultipleSleepDocumentsV2SandboxUsercollectionSleepGet Sandbox - Multiple Sleep Documents

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSandboxMultipleSleepDocumentsV2SandboxUsercollectionSleepGetRequest
*/
func (a *SandboxRoutesAPIService) SandboxMultipleSleepDocumentsV2SandboxUsercollectionSleepGet(ctx context.Context) ApiSandboxMultipleSleepDocumentsV2SandboxUsercollectionSleepGetRequest {
	return ApiSandboxMultipleSleepDocumentsV2SandboxUsercollectionSleepGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MultiDocumentResponseSleepModel
func (a *SandboxRoutesAPIService) SandboxMultipleSleepDocumentsV2SandboxUsercollectionSleepGetExecute(r ApiSandboxMultipleSleepDocumentsV2SandboxUsercollectionSleepGetRequest) (*MultiDocumentResponseSleepModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiDocumentResponseSleepModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxRoutesAPIService.SandboxMultipleSleepDocumentsV2SandboxUsercollectionSleepGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/sandbox/usercollection/sleep"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.nextToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "next_token", r.nextToken, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSandboxMultipleSleepTimeDocumentsV2SandboxUsercollectionSleepTimeGetRequest struct {
	ctx context.Context
	ApiService *SandboxRoutesAPIService
	startDate *StartDate
	endDate *EndDate1
	nextToken *string
}

func (r ApiSandboxMultipleSleepTimeDocumentsV2SandboxUsercollectionSleepTimeGetRequest) StartDate(startDate StartDate) ApiSandboxMultipleSleepTimeDocumentsV2SandboxUsercollectionSleepTimeGetRequest {
	r.startDate = &startDate
	return r
}

func (r ApiSandboxMultipleSleepTimeDocumentsV2SandboxUsercollectionSleepTimeGetRequest) EndDate(endDate EndDate1) ApiSandboxMultipleSleepTimeDocumentsV2SandboxUsercollectionSleepTimeGetRequest {
	r.endDate = &endDate
	return r
}

func (r ApiSandboxMultipleSleepTimeDocumentsV2SandboxUsercollectionSleepTimeGetRequest) NextToken(nextToken string) ApiSandboxMultipleSleepTimeDocumentsV2SandboxUsercollectionSleepTimeGetRequest {
	r.nextToken = &nextToken
	return r
}

func (r ApiSandboxMultipleSleepTimeDocumentsV2SandboxUsercollectionSleepTimeGetRequest) Execute() (*MultiDocumentResponseSleepTimeModel, *http.Response, error) {
	return r.ApiService.SandboxMultipleSleepTimeDocumentsV2SandboxUsercollectionSleepTimeGetExecute(r)
}

/*
SandboxMultipleSleepTimeDocumentsV2SandboxUsercollectionSleepTimeGet Sandbox - Multiple Sleep Time Documents

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSandboxMultipleSleepTimeDocumentsV2SandboxUsercollectionSleepTimeGetRequest
*/
func (a *SandboxRoutesAPIService) SandboxMultipleSleepTimeDocumentsV2SandboxUsercollectionSleepTimeGet(ctx context.Context) ApiSandboxMultipleSleepTimeDocumentsV2SandboxUsercollectionSleepTimeGetRequest {
	return ApiSandboxMultipleSleepTimeDocumentsV2SandboxUsercollectionSleepTimeGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MultiDocumentResponseSleepTimeModel
func (a *SandboxRoutesAPIService) SandboxMultipleSleepTimeDocumentsV2SandboxUsercollectionSleepTimeGetExecute(r ApiSandboxMultipleSleepTimeDocumentsV2SandboxUsercollectionSleepTimeGetRequest) (*MultiDocumentResponseSleepTimeModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiDocumentResponseSleepTimeModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxRoutesAPIService.SandboxMultipleSleepTimeDocumentsV2SandboxUsercollectionSleepTimeGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/sandbox/usercollection/sleep_time"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.nextToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "next_token", r.nextToken, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSandboxMultipleTagDocumentsV2SandboxUsercollectionTagGetRequest struct {
	ctx context.Context
	ApiService *SandboxRoutesAPIService
	startDate *StartDate
	endDate *EndDate1
	nextToken *string
}

func (r ApiSandboxMultipleTagDocumentsV2SandboxUsercollectionTagGetRequest) StartDate(startDate StartDate) ApiSandboxMultipleTagDocumentsV2SandboxUsercollectionTagGetRequest {
	r.startDate = &startDate
	return r
}

func (r ApiSandboxMultipleTagDocumentsV2SandboxUsercollectionTagGetRequest) EndDate(endDate EndDate1) ApiSandboxMultipleTagDocumentsV2SandboxUsercollectionTagGetRequest {
	r.endDate = &endDate
	return r
}

func (r ApiSandboxMultipleTagDocumentsV2SandboxUsercollectionTagGetRequest) NextToken(nextToken string) ApiSandboxMultipleTagDocumentsV2SandboxUsercollectionTagGetRequest {
	r.nextToken = &nextToken
	return r
}

func (r ApiSandboxMultipleTagDocumentsV2SandboxUsercollectionTagGetRequest) Execute() (*MultiDocumentResponseTagModel, *http.Response, error) {
	return r.ApiService.SandboxMultipleTagDocumentsV2SandboxUsercollectionTagGetExecute(r)
}

/*
SandboxMultipleTagDocumentsV2SandboxUsercollectionTagGet Sandbox - Multiple Tag Documents

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSandboxMultipleTagDocumentsV2SandboxUsercollectionTagGetRequest

Deprecated
*/
func (a *SandboxRoutesAPIService) SandboxMultipleTagDocumentsV2SandboxUsercollectionTagGet(ctx context.Context) ApiSandboxMultipleTagDocumentsV2SandboxUsercollectionTagGetRequest {
	return ApiSandboxMultipleTagDocumentsV2SandboxUsercollectionTagGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MultiDocumentResponseTagModel
// Deprecated
func (a *SandboxRoutesAPIService) SandboxMultipleTagDocumentsV2SandboxUsercollectionTagGetExecute(r ApiSandboxMultipleTagDocumentsV2SandboxUsercollectionTagGetRequest) (*MultiDocumentResponseTagModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiDocumentResponseTagModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxRoutesAPIService.SandboxMultipleTagDocumentsV2SandboxUsercollectionTagGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/sandbox/usercollection/tag"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.nextToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "next_token", r.nextToken, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSandboxMultipleVO2MaxDocumentsV2SandboxUsercollectionVO2MaxGetRequest struct {
	ctx context.Context
	ApiService *SandboxRoutesAPIService
	startDate *StartDate
	endDate *EndDate1
	nextToken *string
}

func (r ApiSandboxMultipleVO2MaxDocumentsV2SandboxUsercollectionVO2MaxGetRequest) StartDate(startDate StartDate) ApiSandboxMultipleVO2MaxDocumentsV2SandboxUsercollectionVO2MaxGetRequest {
	r.startDate = &startDate
	return r
}

func (r ApiSandboxMultipleVO2MaxDocumentsV2SandboxUsercollectionVO2MaxGetRequest) EndDate(endDate EndDate1) ApiSandboxMultipleVO2MaxDocumentsV2SandboxUsercollectionVO2MaxGetRequest {
	r.endDate = &endDate
	return r
}

func (r ApiSandboxMultipleVO2MaxDocumentsV2SandboxUsercollectionVO2MaxGetRequest) NextToken(nextToken string) ApiSandboxMultipleVO2MaxDocumentsV2SandboxUsercollectionVO2MaxGetRequest {
	r.nextToken = &nextToken
	return r
}

func (r ApiSandboxMultipleVO2MaxDocumentsV2SandboxUsercollectionVO2MaxGetRequest) Execute() (*MultiDocumentResponseVO2MaxModel, *http.Response, error) {
	return r.ApiService.SandboxMultipleVO2MaxDocumentsV2SandboxUsercollectionVO2MaxGetExecute(r)
}

/*
SandboxMultipleVO2MaxDocumentsV2SandboxUsercollectionVO2MaxGet Sandbox - Multiple Vo2 Max Documents

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSandboxMultipleVO2MaxDocumentsV2SandboxUsercollectionVO2MaxGetRequest
*/
func (a *SandboxRoutesAPIService) SandboxMultipleVO2MaxDocumentsV2SandboxUsercollectionVO2MaxGet(ctx context.Context) ApiSandboxMultipleVO2MaxDocumentsV2SandboxUsercollectionVO2MaxGetRequest {
	return ApiSandboxMultipleVO2MaxDocumentsV2SandboxUsercollectionVO2MaxGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MultiDocumentResponseVO2MaxModel
func (a *SandboxRoutesAPIService) SandboxMultipleVO2MaxDocumentsV2SandboxUsercollectionVO2MaxGetExecute(r ApiSandboxMultipleVO2MaxDocumentsV2SandboxUsercollectionVO2MaxGetRequest) (*MultiDocumentResponseVO2MaxModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiDocumentResponseVO2MaxModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxRoutesAPIService.SandboxMultipleVO2MaxDocumentsV2SandboxUsercollectionVO2MaxGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/sandbox/usercollection/vO2_max"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.nextToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "next_token", r.nextToken, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSandboxMultipleWorkoutDocumentsV2SandboxUsercollectionWorkoutGetRequest struct {
	ctx context.Context
	ApiService *SandboxRoutesAPIService
	startDate *StartDate
	endDate *EndDate1
	nextToken *string
}

func (r ApiSandboxMultipleWorkoutDocumentsV2SandboxUsercollectionWorkoutGetRequest) StartDate(startDate StartDate) ApiSandboxMultipleWorkoutDocumentsV2SandboxUsercollectionWorkoutGetRequest {
	r.startDate = &startDate
	return r
}

func (r ApiSandboxMultipleWorkoutDocumentsV2SandboxUsercollectionWorkoutGetRequest) EndDate(endDate EndDate1) ApiSandboxMultipleWorkoutDocumentsV2SandboxUsercollectionWorkoutGetRequest {
	r.endDate = &endDate
	return r
}

func (r ApiSandboxMultipleWorkoutDocumentsV2SandboxUsercollectionWorkoutGetRequest) NextToken(nextToken string) ApiSandboxMultipleWorkoutDocumentsV2SandboxUsercollectionWorkoutGetRequest {
	r.nextToken = &nextToken
	return r
}

func (r ApiSandboxMultipleWorkoutDocumentsV2SandboxUsercollectionWorkoutGetRequest) Execute() (*MultiDocumentResponseWorkoutModel, *http.Response, error) {
	return r.ApiService.SandboxMultipleWorkoutDocumentsV2SandboxUsercollectionWorkoutGetExecute(r)
}

/*
SandboxMultipleWorkoutDocumentsV2SandboxUsercollectionWorkoutGet Sandbox - Multiple Workout Documents

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSandboxMultipleWorkoutDocumentsV2SandboxUsercollectionWorkoutGetRequest
*/
func (a *SandboxRoutesAPIService) SandboxMultipleWorkoutDocumentsV2SandboxUsercollectionWorkoutGet(ctx context.Context) ApiSandboxMultipleWorkoutDocumentsV2SandboxUsercollectionWorkoutGetRequest {
	return ApiSandboxMultipleWorkoutDocumentsV2SandboxUsercollectionWorkoutGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MultiDocumentResponseWorkoutModel
func (a *SandboxRoutesAPIService) SandboxMultipleWorkoutDocumentsV2SandboxUsercollectionWorkoutGetExecute(r ApiSandboxMultipleWorkoutDocumentsV2SandboxUsercollectionWorkoutGetRequest) (*MultiDocumentResponseWorkoutModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiDocumentResponseWorkoutModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxRoutesAPIService.SandboxMultipleWorkoutDocumentsV2SandboxUsercollectionWorkoutGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/sandbox/usercollection/workout"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	}
	if r.nextToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "next_token", r.nextToken, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSandboxSingleDailyActivityDocumentV2SandboxUsercollectionDailyActivityDocumentIdGetRequest struct {
	ctx context.Context
	ApiService *SandboxRoutesAPIService
	documentId string
}

func (r ApiSandboxSingleDailyActivityDocumentV2SandboxUsercollectionDailyActivityDocumentIdGetRequest) Execute() (*DailyActivityModel, *http.Response, error) {
	return r.ApiService.SandboxSingleDailyActivityDocumentV2SandboxUsercollectionDailyActivityDocumentIdGetExecute(r)
}

/*
SandboxSingleDailyActivityDocumentV2SandboxUsercollectionDailyActivityDocumentIdGet Sandbox - Single Daily Activity Document

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param documentId
 @return ApiSandboxSingleDailyActivityDocumentV2SandboxUsercollectionDailyActivityDocumentIdGetRequest
*/
func (a *SandboxRoutesAPIService) SandboxSingleDailyActivityDocumentV2SandboxUsercollectionDailyActivityDocumentIdGet(ctx context.Context, documentId string) ApiSandboxSingleDailyActivityDocumentV2SandboxUsercollectionDailyActivityDocumentIdGetRequest {
	return ApiSandboxSingleDailyActivityDocumentV2SandboxUsercollectionDailyActivityDocumentIdGetRequest{
		ApiService: a,
		ctx: ctx,
		documentId: documentId,
	}
}

// Execute executes the request
//  @return DailyActivityModel
func (a *SandboxRoutesAPIService) SandboxSingleDailyActivityDocumentV2SandboxUsercollectionDailyActivityDocumentIdGetExecute(r ApiSandboxSingleDailyActivityDocumentV2SandboxUsercollectionDailyActivityDocumentIdGetRequest) (*DailyActivityModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DailyActivityModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxRoutesAPIService.SandboxSingleDailyActivityDocumentV2SandboxUsercollectionDailyActivityDocumentIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/sandbox/usercollection/daily_activity/{document_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"document_id"+"}", url.PathEscape(parameterValueToString(r.documentId, "documentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSandboxSingleDailyCardiovascularAgeDocumentV2SandboxUsercollectionDailyCardiovascularAgeDocumentIdGetRequest struct {
	ctx context.Context
	ApiService *SandboxRoutesAPIService
	documentId string
}

func (r ApiSandboxSingleDailyCardiovascularAgeDocumentV2SandboxUsercollectionDailyCardiovascularAgeDocumentIdGetRequest) Execute() (*DailyCardiovascularAgeModel, *http.Response, error) {
	return r.ApiService.SandboxSingleDailyCardiovascularAgeDocumentV2SandboxUsercollectionDailyCardiovascularAgeDocumentIdGetExecute(r)
}

/*
SandboxSingleDailyCardiovascularAgeDocumentV2SandboxUsercollectionDailyCardiovascularAgeDocumentIdGet Sandbox - Single Daily Cardiovascular Age Document

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param documentId
 @return ApiSandboxSingleDailyCardiovascularAgeDocumentV2SandboxUsercollectionDailyCardiovascularAgeDocumentIdGetRequest
*/
func (a *SandboxRoutesAPIService) SandboxSingleDailyCardiovascularAgeDocumentV2SandboxUsercollectionDailyCardiovascularAgeDocumentIdGet(ctx context.Context, documentId string) ApiSandboxSingleDailyCardiovascularAgeDocumentV2SandboxUsercollectionDailyCardiovascularAgeDocumentIdGetRequest {
	return ApiSandboxSingleDailyCardiovascularAgeDocumentV2SandboxUsercollectionDailyCardiovascularAgeDocumentIdGetRequest{
		ApiService: a,
		ctx: ctx,
		documentId: documentId,
	}
}

// Execute executes the request
//  @return DailyCardiovascularAgeModel
func (a *SandboxRoutesAPIService) SandboxSingleDailyCardiovascularAgeDocumentV2SandboxUsercollectionDailyCardiovascularAgeDocumentIdGetExecute(r ApiSandboxSingleDailyCardiovascularAgeDocumentV2SandboxUsercollectionDailyCardiovascularAgeDocumentIdGetRequest) (*DailyCardiovascularAgeModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DailyCardiovascularAgeModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxRoutesAPIService.SandboxSingleDailyCardiovascularAgeDocumentV2SandboxUsercollectionDailyCardiovascularAgeDocumentIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/sandbox/usercollection/daily_cardiovascular_age/{document_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"document_id"+"}", url.PathEscape(parameterValueToString(r.documentId, "documentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSandboxSingleDailyReadinessDocumentV2SandboxUsercollectionDailyReadinessDocumentIdGetRequest struct {
	ctx context.Context
	ApiService *SandboxRoutesAPIService
	documentId string
}

func (r ApiSandboxSingleDailyReadinessDocumentV2SandboxUsercollectionDailyReadinessDocumentIdGetRequest) Execute() (*DailyReadinessModel, *http.Response, error) {
	return r.ApiService.SandboxSingleDailyReadinessDocumentV2SandboxUsercollectionDailyReadinessDocumentIdGetExecute(r)
}

/*
SandboxSingleDailyReadinessDocumentV2SandboxUsercollectionDailyReadinessDocumentIdGet Sandbox - Single Daily Readiness Document

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param documentId
 @return ApiSandboxSingleDailyReadinessDocumentV2SandboxUsercollectionDailyReadinessDocumentIdGetRequest
*/
func (a *SandboxRoutesAPIService) SandboxSingleDailyReadinessDocumentV2SandboxUsercollectionDailyReadinessDocumentIdGet(ctx context.Context, documentId string) ApiSandboxSingleDailyReadinessDocumentV2SandboxUsercollectionDailyReadinessDocumentIdGetRequest {
	return ApiSandboxSingleDailyReadinessDocumentV2SandboxUsercollectionDailyReadinessDocumentIdGetRequest{
		ApiService: a,
		ctx: ctx,
		documentId: documentId,
	}
}

// Execute executes the request
//  @return DailyReadinessModel
func (a *SandboxRoutesAPIService) SandboxSingleDailyReadinessDocumentV2SandboxUsercollectionDailyReadinessDocumentIdGetExecute(r ApiSandboxSingleDailyReadinessDocumentV2SandboxUsercollectionDailyReadinessDocumentIdGetRequest) (*DailyReadinessModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DailyReadinessModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxRoutesAPIService.SandboxSingleDailyReadinessDocumentV2SandboxUsercollectionDailyReadinessDocumentIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/sandbox/usercollection/daily_readiness/{document_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"document_id"+"}", url.PathEscape(parameterValueToString(r.documentId, "documentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSandboxSingleDailyResilienceDocumentV2SandboxUsercollectionDailyResilienceDocumentIdGetRequest struct {
	ctx context.Context
	ApiService *SandboxRoutesAPIService
	documentId string
}

func (r ApiSandboxSingleDailyResilienceDocumentV2SandboxUsercollectionDailyResilienceDocumentIdGetRequest) Execute() (*DailyResilienceModel, *http.Response, error) {
	return r.ApiService.SandboxSingleDailyResilienceDocumentV2SandboxUsercollectionDailyResilienceDocumentIdGetExecute(r)
}

/*
SandboxSingleDailyResilienceDocumentV2SandboxUsercollectionDailyResilienceDocumentIdGet Sandbox - Single Daily Resilience Document

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param documentId
 @return ApiSandboxSingleDailyResilienceDocumentV2SandboxUsercollectionDailyResilienceDocumentIdGetRequest
*/
func (a *SandboxRoutesAPIService) SandboxSingleDailyResilienceDocumentV2SandboxUsercollectionDailyResilienceDocumentIdGet(ctx context.Context, documentId string) ApiSandboxSingleDailyResilienceDocumentV2SandboxUsercollectionDailyResilienceDocumentIdGetRequest {
	return ApiSandboxSingleDailyResilienceDocumentV2SandboxUsercollectionDailyResilienceDocumentIdGetRequest{
		ApiService: a,
		ctx: ctx,
		documentId: documentId,
	}
}

// Execute executes the request
//  @return DailyResilienceModel
func (a *SandboxRoutesAPIService) SandboxSingleDailyResilienceDocumentV2SandboxUsercollectionDailyResilienceDocumentIdGetExecute(r ApiSandboxSingleDailyResilienceDocumentV2SandboxUsercollectionDailyResilienceDocumentIdGetRequest) (*DailyResilienceModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DailyResilienceModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxRoutesAPIService.SandboxSingleDailyResilienceDocumentV2SandboxUsercollectionDailyResilienceDocumentIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/sandbox/usercollection/daily_resilience/{document_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"document_id"+"}", url.PathEscape(parameterValueToString(r.documentId, "documentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSandboxSingleDailySleepDocumentV2SandboxUsercollectionDailySleepDocumentIdGetRequest struct {
	ctx context.Context
	ApiService *SandboxRoutesAPIService
	documentId string
}

func (r ApiSandboxSingleDailySleepDocumentV2SandboxUsercollectionDailySleepDocumentIdGetRequest) Execute() (*DailySleepModel, *http.Response, error) {
	return r.ApiService.SandboxSingleDailySleepDocumentV2SandboxUsercollectionDailySleepDocumentIdGetExecute(r)
}

/*
SandboxSingleDailySleepDocumentV2SandboxUsercollectionDailySleepDocumentIdGet Sandbox - Single Daily Sleep Document

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param documentId
 @return ApiSandboxSingleDailySleepDocumentV2SandboxUsercollectionDailySleepDocumentIdGetRequest
*/
func (a *SandboxRoutesAPIService) SandboxSingleDailySleepDocumentV2SandboxUsercollectionDailySleepDocumentIdGet(ctx context.Context, documentId string) ApiSandboxSingleDailySleepDocumentV2SandboxUsercollectionDailySleepDocumentIdGetRequest {
	return ApiSandboxSingleDailySleepDocumentV2SandboxUsercollectionDailySleepDocumentIdGetRequest{
		ApiService: a,
		ctx: ctx,
		documentId: documentId,
	}
}

// Execute executes the request
//  @return DailySleepModel
func (a *SandboxRoutesAPIService) SandboxSingleDailySleepDocumentV2SandboxUsercollectionDailySleepDocumentIdGetExecute(r ApiSandboxSingleDailySleepDocumentV2SandboxUsercollectionDailySleepDocumentIdGetRequest) (*DailySleepModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DailySleepModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxRoutesAPIService.SandboxSingleDailySleepDocumentV2SandboxUsercollectionDailySleepDocumentIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/sandbox/usercollection/daily_sleep/{document_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"document_id"+"}", url.PathEscape(parameterValueToString(r.documentId, "documentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSandboxSingleDailySpo2DocumentV2SandboxUsercollectionDailySpo2DocumentIdGetRequest struct {
	ctx context.Context
	ApiService *SandboxRoutesAPIService
	documentId string
}

func (r ApiSandboxSingleDailySpo2DocumentV2SandboxUsercollectionDailySpo2DocumentIdGetRequest) Execute() (*DailySpO2Model, *http.Response, error) {
	return r.ApiService.SandboxSingleDailySpo2DocumentV2SandboxUsercollectionDailySpo2DocumentIdGetExecute(r)
}

/*
SandboxSingleDailySpo2DocumentV2SandboxUsercollectionDailySpo2DocumentIdGet Sandbox - Single Daily Spo2 Document

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param documentId
 @return ApiSandboxSingleDailySpo2DocumentV2SandboxUsercollectionDailySpo2DocumentIdGetRequest
*/
func (a *SandboxRoutesAPIService) SandboxSingleDailySpo2DocumentV2SandboxUsercollectionDailySpo2DocumentIdGet(ctx context.Context, documentId string) ApiSandboxSingleDailySpo2DocumentV2SandboxUsercollectionDailySpo2DocumentIdGetRequest {
	return ApiSandboxSingleDailySpo2DocumentV2SandboxUsercollectionDailySpo2DocumentIdGetRequest{
		ApiService: a,
		ctx: ctx,
		documentId: documentId,
	}
}

// Execute executes the request
//  @return DailySpO2Model
func (a *SandboxRoutesAPIService) SandboxSingleDailySpo2DocumentV2SandboxUsercollectionDailySpo2DocumentIdGetExecute(r ApiSandboxSingleDailySpo2DocumentV2SandboxUsercollectionDailySpo2DocumentIdGetRequest) (*DailySpO2Model, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DailySpO2Model
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxRoutesAPIService.SandboxSingleDailySpo2DocumentV2SandboxUsercollectionDailySpo2DocumentIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/sandbox/usercollection/daily_spo2/{document_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"document_id"+"}", url.PathEscape(parameterValueToString(r.documentId, "documentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSandboxSingleDailyStressDocumentV2SandboxUsercollectionDailyStressDocumentIdGetRequest struct {
	ctx context.Context
	ApiService *SandboxRoutesAPIService
	documentId string
}

func (r ApiSandboxSingleDailyStressDocumentV2SandboxUsercollectionDailyStressDocumentIdGetRequest) Execute() (*DailyStressModel, *http.Response, error) {
	return r.ApiService.SandboxSingleDailyStressDocumentV2SandboxUsercollectionDailyStressDocumentIdGetExecute(r)
}

/*
SandboxSingleDailyStressDocumentV2SandboxUsercollectionDailyStressDocumentIdGet Sandbox - Single Daily Stress Document

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param documentId
 @return ApiSandboxSingleDailyStressDocumentV2SandboxUsercollectionDailyStressDocumentIdGetRequest
*/
func (a *SandboxRoutesAPIService) SandboxSingleDailyStressDocumentV2SandboxUsercollectionDailyStressDocumentIdGet(ctx context.Context, documentId string) ApiSandboxSingleDailyStressDocumentV2SandboxUsercollectionDailyStressDocumentIdGetRequest {
	return ApiSandboxSingleDailyStressDocumentV2SandboxUsercollectionDailyStressDocumentIdGetRequest{
		ApiService: a,
		ctx: ctx,
		documentId: documentId,
	}
}

// Execute executes the request
//  @return DailyStressModel
func (a *SandboxRoutesAPIService) SandboxSingleDailyStressDocumentV2SandboxUsercollectionDailyStressDocumentIdGetExecute(r ApiSandboxSingleDailyStressDocumentV2SandboxUsercollectionDailyStressDocumentIdGetRequest) (*DailyStressModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DailyStressModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxRoutesAPIService.SandboxSingleDailyStressDocumentV2SandboxUsercollectionDailyStressDocumentIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/sandbox/usercollection/daily_stress/{document_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"document_id"+"}", url.PathEscape(parameterValueToString(r.documentId, "documentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSandboxSingleEnhancedTagDocumentV2SandboxUsercollectionEnhancedTagDocumentIdGetRequest struct {
	ctx context.Context
	ApiService *SandboxRoutesAPIService
	documentId string
}

func (r ApiSandboxSingleEnhancedTagDocumentV2SandboxUsercollectionEnhancedTagDocumentIdGetRequest) Execute() (*EnhancedTagModel, *http.Response, error) {
	return r.ApiService.SandboxSingleEnhancedTagDocumentV2SandboxUsercollectionEnhancedTagDocumentIdGetExecute(r)
}

/*
SandboxSingleEnhancedTagDocumentV2SandboxUsercollectionEnhancedTagDocumentIdGet Sandbox - Single Enhanced Tag Document

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param documentId
 @return ApiSandboxSingleEnhancedTagDocumentV2SandboxUsercollectionEnhancedTagDocumentIdGetRequest
*/
func (a *SandboxRoutesAPIService) SandboxSingleEnhancedTagDocumentV2SandboxUsercollectionEnhancedTagDocumentIdGet(ctx context.Context, documentId string) ApiSandboxSingleEnhancedTagDocumentV2SandboxUsercollectionEnhancedTagDocumentIdGetRequest {
	return ApiSandboxSingleEnhancedTagDocumentV2SandboxUsercollectionEnhancedTagDocumentIdGetRequest{
		ApiService: a,
		ctx: ctx,
		documentId: documentId,
	}
}

// Execute executes the request
//  @return EnhancedTagModel
func (a *SandboxRoutesAPIService) SandboxSingleEnhancedTagDocumentV2SandboxUsercollectionEnhancedTagDocumentIdGetExecute(r ApiSandboxSingleEnhancedTagDocumentV2SandboxUsercollectionEnhancedTagDocumentIdGetRequest) (*EnhancedTagModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnhancedTagModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxRoutesAPIService.SandboxSingleEnhancedTagDocumentV2SandboxUsercollectionEnhancedTagDocumentIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/sandbox/usercollection/enhanced_tag/{document_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"document_id"+"}", url.PathEscape(parameterValueToString(r.documentId, "documentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSandboxSingleRestModePeriodDocumentV2SandboxUsercollectionRestModePeriodDocumentIdGetRequest struct {
	ctx context.Context
	ApiService *SandboxRoutesAPIService
	documentId string
}

func (r ApiSandboxSingleRestModePeriodDocumentV2SandboxUsercollectionRestModePeriodDocumentIdGetRequest) Execute() (*RestModePeriodModel, *http.Response, error) {
	return r.ApiService.SandboxSingleRestModePeriodDocumentV2SandboxUsercollectionRestModePeriodDocumentIdGetExecute(r)
}

/*
SandboxSingleRestModePeriodDocumentV2SandboxUsercollectionRestModePeriodDocumentIdGet Sandbox - Single Rest Mode Period Document

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param documentId
 @return ApiSandboxSingleRestModePeriodDocumentV2SandboxUsercollectionRestModePeriodDocumentIdGetRequest
*/
func (a *SandboxRoutesAPIService) SandboxSingleRestModePeriodDocumentV2SandboxUsercollectionRestModePeriodDocumentIdGet(ctx context.Context, documentId string) ApiSandboxSingleRestModePeriodDocumentV2SandboxUsercollectionRestModePeriodDocumentIdGetRequest {
	return ApiSandboxSingleRestModePeriodDocumentV2SandboxUsercollectionRestModePeriodDocumentIdGetRequest{
		ApiService: a,
		ctx: ctx,
		documentId: documentId,
	}
}

// Execute executes the request
//  @return RestModePeriodModel
func (a *SandboxRoutesAPIService) SandboxSingleRestModePeriodDocumentV2SandboxUsercollectionRestModePeriodDocumentIdGetExecute(r ApiSandboxSingleRestModePeriodDocumentV2SandboxUsercollectionRestModePeriodDocumentIdGetRequest) (*RestModePeriodModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RestModePeriodModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxRoutesAPIService.SandboxSingleRestModePeriodDocumentV2SandboxUsercollectionRestModePeriodDocumentIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/sandbox/usercollection/rest_mode_period/{document_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"document_id"+"}", url.PathEscape(parameterValueToString(r.documentId, "documentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSandboxSingleRingConfigurationDocumentV2SandboxUsercollectionRingConfigurationDocumentIdGetRequest struct {
	ctx context.Context
	ApiService *SandboxRoutesAPIService
	documentId string
}

func (r ApiSandboxSingleRingConfigurationDocumentV2SandboxUsercollectionRingConfigurationDocumentIdGetRequest) Execute() (*RingConfigurationModel, *http.Response, error) {
	return r.ApiService.SandboxSingleRingConfigurationDocumentV2SandboxUsercollectionRingConfigurationDocumentIdGetExecute(r)
}

/*
SandboxSingleRingConfigurationDocumentV2SandboxUsercollectionRingConfigurationDocumentIdGet Sandbox - Single Ring Configuration Document

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param documentId
 @return ApiSandboxSingleRingConfigurationDocumentV2SandboxUsercollectionRingConfigurationDocumentIdGetRequest
*/
func (a *SandboxRoutesAPIService) SandboxSingleRingConfigurationDocumentV2SandboxUsercollectionRingConfigurationDocumentIdGet(ctx context.Context, documentId string) ApiSandboxSingleRingConfigurationDocumentV2SandboxUsercollectionRingConfigurationDocumentIdGetRequest {
	return ApiSandboxSingleRingConfigurationDocumentV2SandboxUsercollectionRingConfigurationDocumentIdGetRequest{
		ApiService: a,
		ctx: ctx,
		documentId: documentId,
	}
}

// Execute executes the request
//  @return RingConfigurationModel
func (a *SandboxRoutesAPIService) SandboxSingleRingConfigurationDocumentV2SandboxUsercollectionRingConfigurationDocumentIdGetExecute(r ApiSandboxSingleRingConfigurationDocumentV2SandboxUsercollectionRingConfigurationDocumentIdGetRequest) (*RingConfigurationModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RingConfigurationModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxRoutesAPIService.SandboxSingleRingConfigurationDocumentV2SandboxUsercollectionRingConfigurationDocumentIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/sandbox/usercollection/ring_configuration/{document_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"document_id"+"}", url.PathEscape(parameterValueToString(r.documentId, "documentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSandboxSingleSessionDocumentV2SandboxUsercollectionSessionDocumentIdGetRequest struct {
	ctx context.Context
	ApiService *SandboxRoutesAPIService
	documentId string
}

func (r ApiSandboxSingleSessionDocumentV2SandboxUsercollectionSessionDocumentIdGetRequest) Execute() (*SessionModel, *http.Response, error) {
	return r.ApiService.SandboxSingleSessionDocumentV2SandboxUsercollectionSessionDocumentIdGetExecute(r)
}

/*
SandboxSingleSessionDocumentV2SandboxUsercollectionSessionDocumentIdGet Sandbox - Single Session Document

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param documentId
 @return ApiSandboxSingleSessionDocumentV2SandboxUsercollectionSessionDocumentIdGetRequest
*/
func (a *SandboxRoutesAPIService) SandboxSingleSessionDocumentV2SandboxUsercollectionSessionDocumentIdGet(ctx context.Context, documentId string) ApiSandboxSingleSessionDocumentV2SandboxUsercollectionSessionDocumentIdGetRequest {
	return ApiSandboxSingleSessionDocumentV2SandboxUsercollectionSessionDocumentIdGetRequest{
		ApiService: a,
		ctx: ctx,
		documentId: documentId,
	}
}

// Execute executes the request
//  @return SessionModel
func (a *SandboxRoutesAPIService) SandboxSingleSessionDocumentV2SandboxUsercollectionSessionDocumentIdGetExecute(r ApiSandboxSingleSessionDocumentV2SandboxUsercollectionSessionDocumentIdGetRequest) (*SessionModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SessionModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxRoutesAPIService.SandboxSingleSessionDocumentV2SandboxUsercollectionSessionDocumentIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/sandbox/usercollection/session/{document_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"document_id"+"}", url.PathEscape(parameterValueToString(r.documentId, "documentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSandboxSingleSleepDocumentV2SandboxUsercollectionSleepDocumentIdGetRequest struct {
	ctx context.Context
	ApiService *SandboxRoutesAPIService
	documentId string
}

func (r ApiSandboxSingleSleepDocumentV2SandboxUsercollectionSleepDocumentIdGetRequest) Execute() (*SleepModel, *http.Response, error) {
	return r.ApiService.SandboxSingleSleepDocumentV2SandboxUsercollectionSleepDocumentIdGetExecute(r)
}

/*
SandboxSingleSleepDocumentV2SandboxUsercollectionSleepDocumentIdGet Sandbox - Single Sleep Document

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param documentId
 @return ApiSandboxSingleSleepDocumentV2SandboxUsercollectionSleepDocumentIdGetRequest
*/
func (a *SandboxRoutesAPIService) SandboxSingleSleepDocumentV2SandboxUsercollectionSleepDocumentIdGet(ctx context.Context, documentId string) ApiSandboxSingleSleepDocumentV2SandboxUsercollectionSleepDocumentIdGetRequest {
	return ApiSandboxSingleSleepDocumentV2SandboxUsercollectionSleepDocumentIdGetRequest{
		ApiService: a,
		ctx: ctx,
		documentId: documentId,
	}
}

// Execute executes the request
//  @return SleepModel
func (a *SandboxRoutesAPIService) SandboxSingleSleepDocumentV2SandboxUsercollectionSleepDocumentIdGetExecute(r ApiSandboxSingleSleepDocumentV2SandboxUsercollectionSleepDocumentIdGetRequest) (*SleepModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SleepModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxRoutesAPIService.SandboxSingleSleepDocumentV2SandboxUsercollectionSleepDocumentIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/sandbox/usercollection/sleep/{document_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"document_id"+"}", url.PathEscape(parameterValueToString(r.documentId, "documentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSandboxSingleSleepTimeDocumentV2SandboxUsercollectionSleepTimeDocumentIdGetRequest struct {
	ctx context.Context
	ApiService *SandboxRoutesAPIService
	documentId string
}

func (r ApiSandboxSingleSleepTimeDocumentV2SandboxUsercollectionSleepTimeDocumentIdGetRequest) Execute() (*SleepTimeModel, *http.Response, error) {
	return r.ApiService.SandboxSingleSleepTimeDocumentV2SandboxUsercollectionSleepTimeDocumentIdGetExecute(r)
}

/*
SandboxSingleSleepTimeDocumentV2SandboxUsercollectionSleepTimeDocumentIdGet Sandbox - Single Sleep Time Document

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param documentId
 @return ApiSandboxSingleSleepTimeDocumentV2SandboxUsercollectionSleepTimeDocumentIdGetRequest
*/
func (a *SandboxRoutesAPIService) SandboxSingleSleepTimeDocumentV2SandboxUsercollectionSleepTimeDocumentIdGet(ctx context.Context, documentId string) ApiSandboxSingleSleepTimeDocumentV2SandboxUsercollectionSleepTimeDocumentIdGetRequest {
	return ApiSandboxSingleSleepTimeDocumentV2SandboxUsercollectionSleepTimeDocumentIdGetRequest{
		ApiService: a,
		ctx: ctx,
		documentId: documentId,
	}
}

// Execute executes the request
//  @return SleepTimeModel
func (a *SandboxRoutesAPIService) SandboxSingleSleepTimeDocumentV2SandboxUsercollectionSleepTimeDocumentIdGetExecute(r ApiSandboxSingleSleepTimeDocumentV2SandboxUsercollectionSleepTimeDocumentIdGetRequest) (*SleepTimeModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SleepTimeModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxRoutesAPIService.SandboxSingleSleepTimeDocumentV2SandboxUsercollectionSleepTimeDocumentIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/sandbox/usercollection/sleep_time/{document_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"document_id"+"}", url.PathEscape(parameterValueToString(r.documentId, "documentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSandboxSingleTagDocumentV2SandboxUsercollectionTagDocumentIdGetRequest struct {
	ctx context.Context
	ApiService *SandboxRoutesAPIService
	documentId string
}

func (r ApiSandboxSingleTagDocumentV2SandboxUsercollectionTagDocumentIdGetRequest) Execute() (*TagModel, *http.Response, error) {
	return r.ApiService.SandboxSingleTagDocumentV2SandboxUsercollectionTagDocumentIdGetExecute(r)
}

/*
SandboxSingleTagDocumentV2SandboxUsercollectionTagDocumentIdGet Sandbox - Single Tag Document

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param documentId
 @return ApiSandboxSingleTagDocumentV2SandboxUsercollectionTagDocumentIdGetRequest
*/
func (a *SandboxRoutesAPIService) SandboxSingleTagDocumentV2SandboxUsercollectionTagDocumentIdGet(ctx context.Context, documentId string) ApiSandboxSingleTagDocumentV2SandboxUsercollectionTagDocumentIdGetRequest {
	return ApiSandboxSingleTagDocumentV2SandboxUsercollectionTagDocumentIdGetRequest{
		ApiService: a,
		ctx: ctx,
		documentId: documentId,
	}
}

// Execute executes the request
//  @return TagModel
func (a *SandboxRoutesAPIService) SandboxSingleTagDocumentV2SandboxUsercollectionTagDocumentIdGetExecute(r ApiSandboxSingleTagDocumentV2SandboxUsercollectionTagDocumentIdGetRequest) (*TagModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TagModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxRoutesAPIService.SandboxSingleTagDocumentV2SandboxUsercollectionTagDocumentIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/sandbox/usercollection/tag/{document_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"document_id"+"}", url.PathEscape(parameterValueToString(r.documentId, "documentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSandboxSingleVO2MaxDocumentV2SandboxUsercollectionVO2MaxDocumentIdGetRequest struct {
	ctx context.Context
	ApiService *SandboxRoutesAPIService
	documentId string
}

func (r ApiSandboxSingleVO2MaxDocumentV2SandboxUsercollectionVO2MaxDocumentIdGetRequest) Execute() (*VO2MaxModel, *http.Response, error) {
	return r.ApiService.SandboxSingleVO2MaxDocumentV2SandboxUsercollectionVO2MaxDocumentIdGetExecute(r)
}

/*
SandboxSingleVO2MaxDocumentV2SandboxUsercollectionVO2MaxDocumentIdGet Sandbox - Single Vo2 Max Document

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param documentId
 @return ApiSandboxSingleVO2MaxDocumentV2SandboxUsercollectionVO2MaxDocumentIdGetRequest
*/
func (a *SandboxRoutesAPIService) SandboxSingleVO2MaxDocumentV2SandboxUsercollectionVO2MaxDocumentIdGet(ctx context.Context, documentId string) ApiSandboxSingleVO2MaxDocumentV2SandboxUsercollectionVO2MaxDocumentIdGetRequest {
	return ApiSandboxSingleVO2MaxDocumentV2SandboxUsercollectionVO2MaxDocumentIdGetRequest{
		ApiService: a,
		ctx: ctx,
		documentId: documentId,
	}
}

// Execute executes the request
//  @return VO2MaxModel
func (a *SandboxRoutesAPIService) SandboxSingleVO2MaxDocumentV2SandboxUsercollectionVO2MaxDocumentIdGetExecute(r ApiSandboxSingleVO2MaxDocumentV2SandboxUsercollectionVO2MaxDocumentIdGetRequest) (*VO2MaxModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VO2MaxModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxRoutesAPIService.SandboxSingleVO2MaxDocumentV2SandboxUsercollectionVO2MaxDocumentIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/sandbox/usercollection/vO2_max/{document_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"document_id"+"}", url.PathEscape(parameterValueToString(r.documentId, "documentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSandboxSingleWorkoutDocumentV2SandboxUsercollectionWorkoutDocumentIdGetRequest struct {
	ctx context.Context
	ApiService *SandboxRoutesAPIService
	documentId string
}

func (r ApiSandboxSingleWorkoutDocumentV2SandboxUsercollectionWorkoutDocumentIdGetRequest) Execute() (*WorkoutModel, *http.Response, error) {
	return r.ApiService.SandboxSingleWorkoutDocumentV2SandboxUsercollectionWorkoutDocumentIdGetExecute(r)
}

/*
SandboxSingleWorkoutDocumentV2SandboxUsercollectionWorkoutDocumentIdGet Sandbox - Single Workout Document

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param documentId
 @return ApiSandboxSingleWorkoutDocumentV2SandboxUsercollectionWorkoutDocumentIdGetRequest
*/
func (a *SandboxRoutesAPIService) SandboxSingleWorkoutDocumentV2SandboxUsercollectionWorkoutDocumentIdGet(ctx context.Context, documentId string) ApiSandboxSingleWorkoutDocumentV2SandboxUsercollectionWorkoutDocumentIdGetRequest {
	return ApiSandboxSingleWorkoutDocumentV2SandboxUsercollectionWorkoutDocumentIdGetRequest{
		ApiService: a,
		ctx: ctx,
		documentId: documentId,
	}
}

// Execute executes the request
//  @return WorkoutModel
func (a *SandboxRoutesAPIService) SandboxSingleWorkoutDocumentV2SandboxUsercollectionWorkoutDocumentIdGetExecute(r ApiSandboxSingleWorkoutDocumentV2SandboxUsercollectionWorkoutDocumentIdGetRequest) (*WorkoutModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WorkoutModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SandboxRoutesAPIService.SandboxSingleWorkoutDocumentV2SandboxUsercollectionWorkoutDocumentIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/sandbox/usercollection/workout/{document_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"document_id"+"}", url.PathEscape(parameterValueToString(r.documentId, "documentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
